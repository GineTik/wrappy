import fs from 'fs/promises';
import path from 'path';

export class DependencyInjector {
  
  static async injectDependencies(containerPath, dependencies, packagesBasePath) {
    this._validateInjectDependenciesInput(containerPath, dependencies, packagesBasePath);
    
    const binPath = path.join(containerPath, 'bin');
    await fs.mkdir(binPath, { recursive: true });
    
    for (const dependency of dependencies) {
      await this._injectSingleDependency(binPath, dependency, packagesBasePath);
    }
  }
  
  static _validateInjectDependenciesInput(containerPath, dependencies, packagesBasePath) {
    if (!containerPath || typeof containerPath !== 'string') {
      throw new Error('Container path is required and must be a string');
    }
    
    if (!Array.isArray(dependencies)) {
      throw new Error('Dependencies must be an array');
    }
    
    if (!packagesBasePath || typeof packagesBasePath !== 'string') {
      throw new Error('Packages base path is required and must be a string');
    }
  }
  
  static async _injectSingleDependency(binPath, dependency, packagesBasePath) {
    const { packageName, version } = this._parseDependencyString(dependency);
    const packagePath = path.join(packagesBasePath, packageName);
    
    const packageManifest = await this._loadPackageManifest(packagePath);
    
    if (!packageManifest.exports) {
      console.log(`üì¶ –ü–∞–∫–µ—Ç ${packageName} –Ω–µ –º–∞—î –µ–∫—Å–ø–æ—Ä—Ç—ñ–≤`);
      return;
    }
    
    for (const [commandName, commandPath] of Object.entries(packageManifest.exports)) {
      await this._createCommandWrapper(binPath, commandName, packagePath, commandPath);
    }
  }
  
  static _parseDependencyString(dependencyString) {
    const parts = dependencyString.split('@');
    
    if (parts.length === 1) {
      return { packageName: parts[0], version: 'latest' };
    } else if (parts.length === 2) {
      return { packageName: parts[0], version: parts[1] };
    } else {
      throw new Error(`Invalid dependency format: ${dependencyString}`);
    }
  }
  
  static async _loadPackageManifest(packagePath) {
    try {
      const manifestPath = path.join(packagePath, 'manifest.json');
      const content = await fs.readFile(manifestPath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      throw new Error(`Failed to load package manifest at ${packagePath}: ${error.message}`);
    }
  }
  
  static async _createCommandWrapper(binPath, commandName, packagePath, commandPath) {
    const wrapperPath = path.join(binPath, commandName);
    const absoluteCommandPath = path.resolve(packagePath, commandPath);
    
    const wrapperScript = `#!/bin/bash

# Auto-generated wrapper for ${commandName} from package
# Generated by Wrappy dependency injection system

exec "${absoluteCommandPath}" "$@"
`;
    
    await fs.writeFile(wrapperPath, wrapperScript);
    await fs.chmod(wrapperPath, 0o755);
    
    console.log(`üîß –°—Ç–≤–æ—Ä–µ–Ω–æ wrapper –¥–ª—è ${commandName}: ${wrapperPath}`);
  }
  
  static async removeDependencyInjection(containerPath) {
    const binPath = path.join(containerPath, 'bin');
    
    try {
      await fs.rmdir(binPath, { recursive: true });
      console.log(`üóëÔ∏è –í–∏–¥–∞–ª–µ–Ω–æ injected dependencies –∑ ${containerPath}`);
    } catch (error) {
      if (error.code !== 'ENOENT') {
        console.error(`–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤–∏–¥–∞–ª–µ–Ω–Ω—ñ bin –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó: ${error.message}`);
      }
    }
  }
  
  static async listInjectedCommands(containerPath) {
    const binPath = path.join(containerPath, 'bin');
    
    try {
      const commands = await fs.readdir(binPath);
      return commands;
    } catch (error) {
      if (error.code === 'ENOENT') {
        return [];
      }
      throw error;
    }
  }
}